commit 0ebe27be41bd790fb8ea6e44ff2cde33d11015ad
Merge: 347abaf 289e11a
Author: So2ln <sorrinj77@snu.ac.kr>
Date:   Mon Oct 6 19:54:38 2025 +0900

    WIP on dev: 347abaf â™»ï¸ enum êµ¬ì¡°í™” ë° AppText ìœ„ì ¯ ì¶”ê°€ (#68)

diff --cc lib/core/routers/router.dart
index 5a834b7,5a834b7..dbe04ab
--- a/lib/core/routers/router.dart
+++ b/lib/core/routers/router.dart
@@@ -1,3 -1,3 +1,4 @@@
++import 'package:dailymoji/core/constants/app_text_strings.dart';
  import 'package:dailymoji/presentation/pages/my/character_setting/character_setting_page.dart';
  import 'package:dailymoji/presentation/pages/chat/chat_page.dart';
  import 'package:dailymoji/presentation/pages/home/home_page.dart';
@@@ -121,15 -121,15 +122,15 @@@ final routerProvider = Provider<GoRoute
            builder: (context, state) {
              final title = state.pathParameters["title"] ?? "";
              switch (title) {
--              case "ì–¸ì–´ ì„¤ì •":
++              case AppTextStrings.languageSettings:
                  return PreparingPage(title);
--              case "ê³µì§€ì‚¬í•­":
--              case "ì´ìš© ì•½ê´€":
--              case "ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨":
--              case "ìƒë‹´ì„¼í„° ì—°ê²°":
++              case AppTextStrings.notice:
++              case AppTextStrings.termsOfService:
++              case AppTextStrings.privacyPolicy:
++              case AppTextStrings.counselingCenter:
                  return InfoWebViewPage(title: title);
                default:
--                return PreparingPage("ì¤€ë¹„ì¤‘");
++                return PreparingPage(AppTextStrings.pageIsPreparing);
              }
              // TODO: ìœ„ì— ì½”ë“œë¡œ í•©ì³ì„œ ì§„í–‰í•˜ì˜€ìŒ í™•ì¸ í›„ í•„ìš”ì—†ìœ¼ë©´ ì‚­ì œ
              // if (title == "ê³µì§€ì‚¬í•­") {
diff --cc lib/data/data_sources/cluster_scores_data_source.dart
index 8b61bc6,8b61bc6..1dbcb3c
--- a/lib/data/data_sources/cluster_scores_data_source.dart
+++ b/lib/data/data_sources/cluster_scores_data_source.dart
@@@ -11,7 -11,7 +11,8 @@@ abstract interface class ClusterScoresD
      required DateTime endExclusive,
    });
  
--  Future<List<ClusterScoreDto>> fetchByUserAndMonth({
++  // RIN: ê¸°ì¡´ fetchByUserAndMonthê°€ RPC í˜¸ì¶œì„ ìœ„í•œ ìƒˆ í•¨ìˆ˜ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.
++  Future<List<ClusterScoreDto>> fetchDailyMaxByUserAndMonth({
      required String userId,
      required int year,
      required int month,
diff --cc lib/data/data_sources/cluster_scores_data_source_impl.dart
index d5fb10f,d5fb10f..74708a8
--- a/lib/data/data_sources/cluster_scores_data_source_impl.dart
+++ b/lib/data/data_sources/cluster_scores_data_source_impl.dart
@@@ -51,39 -51,39 +51,69 @@@ class ClusterScoresDataSourceImpl imple
      return (res as List).map((e) => ClusterScoreDto.fromJson(e)).toList();
    }
  
--  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  // 1) íŠ¹ì • ì—°ë„/ì›”ì˜ "í•´ë‹¹ ì‚¬ìš©ì" ë°ì´í„°ë§Œ
--  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
++// RIN: ê¸°ì¡´ì—ëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ ê°€ì ¸ì™”ì§€ë§Œ, ì´ì œëŠ” Supabase RPCë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
++  // Supabase í”„ë¡œì íŠ¸ì— 'get_daily_max_cluster_scores' í•¨ìˆ˜ë¥¼ ì´ìš©í•œ ì½”ë“œ!
    @override
--  Future<List<ClusterScoreDto>> fetchByUserAndMonth({
++  Future<List<ClusterScoreDto>> fetchDailyMaxByUserAndMonth({
      required String userId,
      required int year,
      required int month,
    }) async {
      try {
--      final startOfMonthLocal = DateTime(year, month, 1);
--      final startOfNextMonthLocal = (month == 12)
--          ? DateTime(year + 1, 1, 1)
--          : DateTime(year, month + 1, 1);
--
--      final startIso = startOfMonthLocal.toUtc().toIso8601String();
--      final endIso = startOfNextMonthLocal.toUtc().toIso8601String();
--
--      final res = await client
--          .from('cluster_scores')
--          .select() // ìŠ¬ë¦¼ í˜ì´ë¡œë“œ ê¶Œì¥
--          .eq('user_id', userId)
--          .gte('created_at', startIso)
--          .lt('created_at', endIso)
--          .order('created_at', ascending: true);
++      final response = await client.rpc(
++        'get_daily_max_cluster_scores',
++        params: {
++          'p_user_id': userId,
++          'p_year': year,
++          'p_month': month,
++        },
++      );
++
++      // RPC ê²°ê³¼ëŠ” List<dynamic> íƒ€ì…ì´ë¯€ë¡œ, DTOë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
++      final data = (response as List)
++          .map((json) => ClusterScoreDto.fromJson(json))
++          .toList();
  
--      return (res as List).map((e) => ClusterScoreDto.fromJson(e)).toList();
++      return data;
      } catch (e) {
--      throw Exception('fetchByUserAndMonth error: $e');
++      throw Exception("fetchDailyMaxByUserAndMonth RPC error: $e");
      }
    }
  }
  
++//   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
++//   // 1) íŠ¹ì • ì—°ë„/ì›”ì˜ "í•´ë‹¹ ì‚¬ìš©ì" ë°ì´í„°ë§Œ
++//   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
++//   @override
++//   Future<List<ClusterScoreDto>> fetchByUserAndMonth({
++//     required String userId,
++//     required int year,
++//     required int month,
++//   }) async {
++//     try {
++//       final startOfMonthLocal = DateTime(year, month, 1);
++//       final startOfNextMonthLocal = (month == 12)
++//           ? DateTime(year + 1, 1, 1)
++//           : DateTime(year, month + 1, 1);
++
++//       final startIso = startOfMonthLocal.toUtc().toIso8601String();
++//       final endIso = startOfNextMonthLocal.toUtc().toIso8601String();
++
++//       final res = await client
++//           .from('cluster_scores')
++//           .select() // ìŠ¬ë¦¼ í˜ì´ë¡œë“œ ê¶Œì¥
++//           .eq('user_id', userId)
++//           .gte('created_at', startIso)
++//           .lt('created_at', endIso)
++//           .order('created_at', ascending: true);
++
++//       return (res as List).map((e) => ClusterScoreDto.fromJson(e)).toList();
++//     } catch (e) {
++//       throw Exception('fetchByUserAndMonth error: $e');
++//     }
++//   }
++// }
++
  // import 'package:dailymoji/data/dtos/cluster_scores.dart';
  // import 'package:supabase_flutter/supabase_flutter.dart';
  
diff --cc lib/data/repositories/cluster_scores_repository_impl.dart
index c1e6e8b,c1e6e8b..7a25b4e
--- a/lib/data/repositories/cluster_scores_repository_impl.dart
+++ b/lib/data/repositories/cluster_scores_repository_impl.dart
@@@ -45,85 -45,85 +45,103 @@@ class ClusterScoresRepositoryImpl imple
      return _toEntities(dtos);
    }
  
--  // DTO â†’ ìŠ¬ë¦¼ Entity ë§¤í•‘
--  List<ClusterScore> _toEntities(List<ClusterScoreDto> dtos) {
--    return dtos.map((d) {
--      return ClusterScore(
--        userId: d.userId ?? '',
--        createdAt:
--            d.createdAt ?? DateTime.fromMillisecondsSinceEpoch(0, isUtc: true),
--        cluster: d.cluster ?? '',
--        score: d.score ?? 0.0,
--      );
--    }).toList();
--  }
--
--  // í•œë‹¬ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
++// ğŸ§¡ [ê°œì„ ] ë³µì¡í–ˆë˜ _pickDailyMax í•¨ìˆ˜ê°€ ì œê±°ë˜ê³ , RPCë¥¼ í˜¸ì¶œí•˜ëŠ” ë°ì´í„° ì†ŒìŠ¤ í•¨ìˆ˜ë¥¼ ì§ì ‘ ì‚¬ìš©í•©ë‹ˆë‹¤.
++  // ì´ì œ RepositoryëŠ” ë°ì´í„°ë¥¼ ë³€í™˜í•˜ëŠ” ì—­í• ì—ë§Œ ì§‘ì¤‘í•©ë‹ˆë‹¤.
    @override
    Future<List<ClusterScore>> fetchByUserAndMonth({
      required String userId,
      required int year,
      required int month,
    }) async {
--    final dtos = await dataSource.fetchByUserAndMonth(
++    final dtos = await dataSource.fetchDailyMaxByUserAndMonth(
        userId: userId,
        year: year,
        month: month,
      );
  
--    return _pickDailyMax(dtos);
++    // ì„œë²„ì—ì„œ ì´ë¯¸ ê³„ì‚°ëœ ë°ì´í„°ë¥¼ ì—”í‹°í‹°ë¡œ ë³€í™˜í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.
++    return _toEntities(dtos);
    }
  
--  /// ìš”êµ¬ì‚¬í•­:
--  /// 1) í•œë‹¬ DTO ë¦¬ìŠ¤íŠ¸ ì…ë ¥
--  /// 2) í•˜ë£¨ë³„ ìµœëŒ€ ì ìˆ˜(ë™ì ì´ë©´ ë” ìµœì‹  createdAt) í•œ ê±´ë§Œ ì„ íƒ
--  /// 3) ìµœì¢… ë°˜í™˜ì€ List<ClusterScore> (ì—”í‹°í‹°)
--  List<ClusterScore> _pickDailyMax(List<ClusterScoreDto> monthRows) {
--    if (monthRows.isEmpty) return <ClusterScore>[];
--
--    // ë‚ ì§œ(ë¡œì»¬ 00:00)ë¥¼ í‚¤ë¡œ, ê·¸ ë‚ ì§œì˜ ìµœê³  DTO í•œ ê±´ì„ ê°’ìœ¼ë¡œ
--    final byDayMax = <DateTime, ClusterScoreDto>{};
--
--    for (final row in monthRows) {
--      final createdAt = row.createdAt;
--      final score = row.score;
--
--      // í•„ìˆ˜ ê°’ ë„ì´ë©´ ìŠ¤í‚µ (ê¸°ë³¸ê°’ ì±„ìš°ëŠ” ê²ƒë³´ë‹¤ ì™œê³¡ì´ ì ìŒ)
--      if (createdAt == null || score == null) continue;
--
--      // "í•˜ë£¨" ê²½ê³„ë¥¼ ë¡œì»¬(ë””ë°”ì´ìŠ¤ TZ) ê¸°ì¤€ìœ¼ë¡œ ë¬¶ìŒ (í•œêµ­ì´ë©´ KST)
--      final local = createdAt.toLocal();
--      final dayKey = DateTime(local.year, local.month, local.day); // ë¡œì»¬ ìì •
--
--      final cur = byDayMax[dayKey];
--
--      // ì ìˆ˜ ìš°ì„ , ë™ì ì´ë©´ ë” ìµœì‹  createdAt
--      if (cur == null ||
--          score > (cur.score ?? double.negativeInfinity) ||
--          (score == cur.score &&
--              cur.createdAt != null &&
--              createdAt.isAfter(cur.createdAt!))) {
--        byDayMax[dayKey] = row;
--      }
--    }
--
--    // ì—”í‹°í‹°ë¡œ ë³€í™˜ + ì •ë ¬
--    // ì •ë ¬ ê¸°ì¤€ì„ 'í•˜ë£¨' ìˆœì„œë¡œ ì •í™•íˆ ë§ì¶”ê³  ì‹¶ë‹¤ë©´ key(=dayKey)ë¡œ ì •ë ¬
--    final sortedKeys = byDayMax.keys.toList()..sort();
--
--    final result = <ClusterScore>[];
--    for (final key in sortedKeys) {
--      final d = byDayMax[key]!; // keyë¡œ êº¼ë‚¸ DTO (createdAt/scoreëŠ” ìœ„ì—ì„œ ë³´ì¥ë¨)
--
--      result.add(
--        ClusterScore(
--          userId: d.userId ?? '',
--          createdAt: d.createdAt!.toUtc(), // ì €ì¥/ì—°ì‚°ì€ UTC ê¶Œì¥
--          cluster: d.cluster ?? 'unknown', // enumì´ë©´ parseCluster(d.cluster)
--          score: d.score!, // null ê°€ë“œ í–ˆìœ¼ë‹ˆ !
--        ),
++  // DTO â†’ ìŠ¬ë¦¼ Entity ë§¤í•‘
++  List<ClusterScore> _toEntities(List<ClusterScoreDto> dtos) {
++    return dtos.map((d) {
++      return ClusterScore(
++        userId: d.userId ?? '',
++        createdAt:
++            d.createdAt ?? DateTime.fromMillisecondsSinceEpoch(0, isUtc: true),
++        cluster: d.cluster ?? '',
++        score: d.score ?? 0.0,
        );
--    }
--    return result;
++    }).toList();
    }
++
++//   // í•œë‹¬ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
++//   @override
++//   Future<List<ClusterScore>> fetchByUserAndMonth({
++//     required String userId,
++//     required int year,
++//     required int month,
++//   }) async {
++//     final dtos = await dataSource.fetchByUserAndMonth(
++//       userId: userId,
++//       year: year,
++//       month: month,
++//     );
++
++//     return _pickDailyMax(dtos);
++//   }
++
++//   /// ìš”êµ¬ì‚¬í•­:
++//   /// 1) í•œë‹¬ DTO ë¦¬ìŠ¤íŠ¸ ì…ë ¥
++//   /// 2) í•˜ë£¨ë³„ ìµœëŒ€ ì ìˆ˜(ë™ì ì´ë©´ ë” ìµœì‹  createdAt) í•œ ê±´ë§Œ ì„ íƒ
++//   /// 3) ìµœì¢… ë°˜í™˜ì€ List<ClusterScore> (ì—”í‹°í‹°)
++//   List<ClusterScore> _pickDailyMax(List<ClusterScoreDto> monthRows) {
++//     if (monthRows.isEmpty) return <ClusterScore>[];
++
++//     // ë‚ ì§œ(ë¡œì»¬ 00:00)ë¥¼ í‚¤ë¡œ, ê·¸ ë‚ ì§œì˜ ìµœê³  DTO í•œ ê±´ì„ ê°’ìœ¼ë¡œ
++//     final byDayMax = <DateTime, ClusterScoreDto>{};
++
++//     for (final row in monthRows) {
++//       final createdAt = row.createdAt;
++//       final score = row.score;
++
++//       // í•„ìˆ˜ ê°’ ë„ì´ë©´ ìŠ¤í‚µ (ê¸°ë³¸ê°’ ì±„ìš°ëŠ” ê²ƒë³´ë‹¤ ì™œê³¡ì´ ì ìŒ)
++//       if (createdAt == null || score == null) continue;
++
++//       // "í•˜ë£¨" ê²½ê³„ë¥¼ ë¡œì»¬(ë””ë°”ì´ìŠ¤ TZ) ê¸°ì¤€ìœ¼ë¡œ ë¬¶ìŒ (í•œêµ­ì´ë©´ KST)
++//       final local = createdAt.toLocal();
++//       final dayKey = DateTime(local.year, local.month, local.day); // ë¡œì»¬ ìì •
++
++//       final cur = byDayMax[dayKey];
++
++//       // ì ìˆ˜ ìš°ì„ , ë™ì ì´ë©´ ë” ìµœì‹  createdAt
++//       if (cur == null ||
++//           score > (cur.score ?? double.negativeInfinity) ||
++//           (score == cur.score &&
++//               cur.createdAt != null &&
++//               createdAt.isAfter(cur.createdAt!))) {
++//         byDayMax[dayKey] = row;
++//       }
++//     }
++
++//     // ì—”í‹°í‹°ë¡œ ë³€í™˜ + ì •ë ¬
++//     // ì •ë ¬ ê¸°ì¤€ì„ 'í•˜ë£¨' ìˆœì„œë¡œ ì •í™•íˆ ë§ì¶”ê³  ì‹¶ë‹¤ë©´ key(=dayKey)ë¡œ ì •ë ¬
++//     final sortedKeys = byDayMax.keys.toList()..sort();
++
++//     final result = <ClusterScore>[];
++//     for (final key in sortedKeys) {
++//       final d = byDayMax[key]!; // keyë¡œ êº¼ë‚¸ DTO (createdAt/scoreëŠ” ìœ„ì—ì„œ ë³´ì¥ë¨)
++
++//       result.add(
++//         ClusterScore(
++//           userId: d.userId ?? '',
++//           createdAt: d.createdAt!.toUtc(), // ì €ì¥/ì—°ì‚°ì€ UTC ê¶Œì¥
++//           cluster: d.cluster ?? 'unknown', // enumì´ë©´ parseCluster(d.cluster)
++//           score: d.score!, // null ê°€ë“œ í–ˆìœ¼ë‹ˆ !
++//         ),
++//       );
++//     }
++//     return result;
++//   }
  }
diff --cc lib/data/repositories/session_repository.dart
index f75e07b,f75e07b..7864583
--- a/lib/data/repositories/session_repository.dart
+++ b/lib/data/repositories/session_repository.dart
@@@ -10,6 -10,6 +10,16 @@@ class DailyStat 
    final double? avg;
  
    const DailyStat({required this.day, this.max, this.min, this.avg});
++
++// RIN: RPC ì‘ë‹µ(JSON)ì—ì„œ DailyStat ê°ì²´ë¡œ ë³€í™˜í•˜ê¸° ìœ„í•œ factory ìƒì„±ì ì¶”ê°€
++  factory DailyStat.fromJson(Map<String, dynamic> json) {
++    return DailyStat(
++      day: DateTime.parse(json['day']),
++      max: (json['max_g_score'] as num?)?.toDouble(),
++      min: (json['min_g_score'] as num?)?.toDouble(),
++      avg: (json['avg_g_score'] as num?)?.toDouble(),
++    );
++  }
  }
  
  class SessionRepository {
@@@ -17,116 -17,116 +27,156 @@@
  
    SessionRepository(this._client);
  
--  static const _table = 'sessions';
--  static const _cols = 'created_at, user_id, g_score';
--
--  /// ì™¸ë¶€ì—ì„œ í•œ ë²ˆë§Œ í˜¸ì¶œí•˜ë©´ 1~3ë‹¨ê³„ë¥¼ ëª¨ë‘ ìˆ˜í–‰í•´ ë°˜í™˜í•©ë‹ˆë‹¤.
++// RIN: í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì§ì ‘ í†µê³„ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì œê±°í•˜ê³ ,
++  // Supabase RPCë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ë¯¸ ê³„ì‚°ëœ í†µê³„ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
++  // Supabase í”„ë¡œì íŠ¸ì— ìˆëŠ” 'get_daily_gscore_stats' í•¨ìˆ˜ë¥¼ ì´ìš©í•œ ì½”ë“œ
    Future<List<DailyStat>> fetchDailyStatsLast14Days({
      required String userId,
      DateTime? now,
--    bool fillMissingWithZero = false, // trueë©´ ë°ì´í„° ì—†ëŠ” ë‚ ì„ 0,0,0ìœ¼ë¡œ ì±„ì›€
--  }) async {
--    final _now = now ?? DateTime.now();
--    final endAtUtc = _now.toUtc();
--    final startAtUtc = endAtUtc.subtract(const Duration(days: 14));
--
--    final sessions = await _fetchRawLast14Days(
--      userId: userId,
--      startAtUtc: startAtUtc,
--      endAtUtc: endAtUtc,
--    );
--
--    return _computeDailyStatsKst(
--      sessions14d: sessions,
--      startAtUtc: startAtUtc,
--      endAtUtc: endAtUtc,
--      fillMissingWithZero: fillMissingWithZero,
--    );
--  }
--
--  // ===== 1) ìµœê·¼ 14ì¼ raw ì„¸ì…˜ ê°€ì ¸ì˜¤ê¸° =====
--  Future<List<SessionDto>> _fetchRawLast14Days({
--    required String userId,
--    required DateTime startAtUtc,
--    required DateTime endAtUtc,
++    bool fillMissingWithZero = false, // ì´ ì˜µì…˜ì€ ì´ì œ ì„œë²„ í•¨ìˆ˜ ë¡œì§ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
    }) async {
      try {
--      final query = _client
--          .from(_table)
--          .select(_cols)
--          .eq('user_id', userId)
--          .gte('created_at', startAtUtc.toIso8601String())
--          .lt('created_at', endAtUtc.toIso8601String())
--          .order('created_at', ascending: true);
--
--      final List<dynamic> rows = await query;
--      return rows
++      final _now = now ?? DateTime.now();
++      // ì„œë²„ í•¨ìˆ˜ì— ì „ë‹¬í•  ì‹œì‘ì¼ê³¼ ì¢…ë£Œì¼ì„ ISO 8601 í˜•ì‹ì˜ ë¬¸ìì—´ë¡œ ì¤€ë¹„í•©ë‹ˆë‹¤.
++      final endDate = _now.toUtc();
++      final startDate = endDate.subtract(const Duration(days: 14));
++
++      final List<dynamic> response = await _client.rpc(
++        'get_daily_gscore_stats',
++        params: {
++          'p_user_id': userId,
++          'p_start_date': startDate.toIso8601String(),
++          'p_end_date': endDate.toIso8601String(),
++        },
++      );
++
++      // RPC í˜¸ì¶œ ê²°ê³¼ë¥¼ DailyStat ê°ì²´ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
++      return response
            .cast<Map<String, dynamic>>()
--          .map(SessionDto.fromJson)
++          .map(DailyStat.fromJson)
            .toList();
      } on PostgrestException catch (e, s) {
--      log('_fetchRawLast14Days PostgrestException: ${e.message}',
++      log('fetchDailyStatsLast14Days PostgrestException: ${e.message}',
            stackTrace: s);
        rethrow;
      } catch (e, s) {
--      log('_fetchRawLast14Days Unknown error: $e', stackTrace: s);
++      log('fetchDailyStatsLast14Days Unknown error: $e', stackTrace: s);
        rethrow;
      }
    }
--
--  // ===== 2+3) ë‚ ì§œ(KST) ë²„í‚·íŒ… + max/min/avg ê³„ì‚° =====
--  List<DailyStat> _computeDailyStatsKst({
--    required List<SessionDto> sessions14d,
--    required DateTime startAtUtc,
--    required DateTime endAtUtc,
--    required bool fillMissingWithZero,
--  }) {
--    // 2-1) 14ì¼ í‚¤(ìì • KST) ë¯¸ë¦¬ ìƒì„±
--    final startKst = _toKstMidnight(startAtUtc);
--    final endKst = _toKstMidnight(endAtUtc);
--    final map = <DateTime, List<double>>{};
--
--    for (DateTime d = startKst;
--        !d.isAfter(endKst.subtract(const Duration(days: 1)));
--        d = d.add(const Duration(days: 1))) {
--      map[d] = <double>[];
--    }
--
--    // 2-2) ì„¸ì…˜ì„ í•´ë‹¹ ë‚ ì§œ ë°”êµ¬ë‹ˆì— ë‹´ê¸°
--    for (final s in sessions14d) {
--      if (s.createdAt == null || s.gScore == null) continue;
--      final kst = s.createdAt!.toUtc().add(const Duration(hours: 9));
--      final key = DateTime(kst.year, kst.month, kst.day);
--      if (map.containsKey(key)) {
--        map[key]!.add(s.gScore!);
--      }
--    }
--
--    // 3) ê° ë‚ ì§œë³„ max/min/avg ê³„ì‚°
--    final result = <DailyStat>[];
--    final keys = map.keys.toList()..sort((a, b) => a.compareTo(b));
--
--    for (final day in keys) {
--      final scores = map[day]!..sort();
--      if (scores!.isEmpty) {
--        result.add(
--          fillMissingWithZero
--              ? DailyStat(day: day, max: 0, min: 0, avg: 0)
--              : DailyStat(day: day, max: null, min: null, avg: null),
--        );
--        continue;
--      }
--      final max = scores.last;
--      final min = scores.first;
--      final avg = scores.reduce((a, b) => a + b) / scores.length;
--      result.add(DailyStat(day: day, max: max, min: min, avg: avg));
--    }
--    return result;
--  }
--
--  // UTC/ë¡œì»¬ ì–´ë–¤ ê°’ì´ ì™€ë„ KST ìì •ìœ¼ë¡œ ë‚´ë¦¼
--  DateTime _toKstMidnight(DateTime dt) {
--    final kst = dt.toUtc().add(const Duration(hours: 9));
--    return DateTime(kst.year, kst.month, kst.day);
--  }
  }
++
++// RIN: ì•„ë˜ëŠ” ì„œë²„ì—ì„œ ê³„ì‚°ëœê±¸ ê°€ì ¸ì˜¤ê²Œ ë˜ë©´ ì—¬ê¸°ì„œ ì²˜ë¦¬í•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤~!
++//   static const _table = 'sessions';
++//   static const _cols = 'created_at, user_id, g_score';
++
++//   /// ì™¸ë¶€ì—ì„œ í•œ ë²ˆë§Œ í˜¸ì¶œí•˜ë©´ 1~3ë‹¨ê³„ë¥¼ ëª¨ë‘ ìˆ˜í–‰í•´ ë°˜í™˜í•©ë‹ˆë‹¤.
++//   Future<List<DailyStat>> fetchDailyStatsLast14Days({
++//     required String userId,
++//     DateTime? now,
++//     bool fillMissingWithZero = false, // trueë©´ ë°ì´í„° ì—†ëŠ” ë‚ ì„ 0,0,0ìœ¼ë¡œ ì±„ì›€
++//   }) async {
++//     final _now = now ?? DateTime.now();
++//     final endAtUtc = _now.toUtc();
++//     final startAtUtc = endAtUtc.subtract(const Duration(days: 14));
++
++//     final sessions = await _fetchRawLast14Days(
++//       userId: userId,
++//       startAtUtc: startAtUtc,
++//       endAtUtc: endAtUtc,
++//     );
++
++//     return _computeDailyStatsKst(
++//       sessions14d: sessions,
++//       startAtUtc: startAtUtc,
++//       endAtUtc: endAtUtc,
++//       fillMissingWithZero: fillMissingWithZero,
++//     );
++//   }
++
++//   // ===== 1) ìµœê·¼ 14ì¼ raw ì„¸ì…˜ ê°€ì ¸ì˜¤ê¸° =====
++//   Future<List<SessionDto>> _fetchRawLast14Days({
++//     required String userId,
++//     required DateTime startAtUtc,
++//     required DateTime endAtUtc,
++//   }) async {
++//     try {
++//       final query = _client
++//           .from(_table)
++//           .select(_cols)
++//           .eq('user_id', userId)
++//           .gte('created_at', startAtUtc.toIso8601String())
++//           .lt('created_at', endAtUtc.toIso8601String())
++//           .order('created_at', ascending: true);
++
++//       final List<dynamic> rows = await query;
++//       return rows
++//           .cast<Map<String, dynamic>>()
++//           .map(SessionDto.fromJson)
++//           .toList();
++//     } on PostgrestException catch (e, s) {
++//       log('_fetchRawLast14Days PostgrestException: ${e.message}',
++//           stackTrace: s);
++//       rethrow;
++//     } catch (e, s) {
++//       log('_fetchRawLast14Days Unknown error: $e', stackTrace: s);
++//       rethrow;
++//     }
++//   }
++
++//   // ===== 2+3) ë‚ ì§œ(KST) ë²„í‚·íŒ… + max/min/avg ê³„ì‚° =====
++//   List<DailyStat> _computeDailyStatsKst({
++//     required List<SessionDto> sessions14d,
++//     required DateTime startAtUtc,
++//     required DateTime endAtUtc,
++//     required bool fillMissingWithZero,
++//   }) {
++//     // 2-1) 14ì¼ í‚¤(ìì • KST) ë¯¸ë¦¬ ìƒì„±
++//     final startKst = _toKstMidnight(startAtUtc);
++//     final endKst = _toKstMidnight(endAtUtc);
++//     final map = <DateTime, List<double>>{};
++
++//     for (DateTime d = startKst;
++//         !d.isAfter(endKst.subtract(const Duration(days: 1)));
++//         d = d.add(const Duration(days: 1))) {
++//       map[d] = <double>[];
++//     }
++
++//     // 2-2) ì„¸ì…˜ì„ í•´ë‹¹ ë‚ ì§œ ë°”êµ¬ë‹ˆì— ë‹´ê¸°
++//     for (final s in sessions14d) {
++//       if (s.createdAt == null || s.gScore == null) continue;
++//       final kst = s.createdAt!.toUtc().add(const Duration(hours: 9));
++//       final key = DateTime(kst.year, kst.month, kst.day);
++//       if (map.containsKey(key)) {
++//         map[key]!.add(s.gScore!);
++//       }
++//     }
++
++//     // 3) ê° ë‚ ì§œë³„ max/min/avg ê³„ì‚°
++//     final result = <DailyStat>[];
++//     final keys = map.keys.toList()..sort((a, b) => a.compareTo(b));
++
++//     for (final day in keys) {
++//       final scores = map[day]!..sort();
++//       if (scores!.isEmpty) {
++//         result.add(
++//           fillMissingWithZero
++//               ? DailyStat(day: day, max: 0, min: 0, avg: 0)
++//               : DailyStat(day: day, max: null, min: null, avg: null),
++//         );
++//         continue;
++//       }
++//       final max = scores.last;
++//       final min = scores.first;
++//       final avg = scores.reduce((a, b) => a + b) / scores.length;
++//       result.add(DailyStat(day: day, max: max, min: min, avg: avg));
++//     }
++//     return result;
++//   }
++
++//   // UTC/ë¡œì»¬ ì–´ë–¤ ê°’ì´ ì™€ë„ KST ìì •ìœ¼ë¡œ ë‚´ë¦¼
++//   DateTime _toKstMidnight(DateTime dt) {
++//     final kst = dt.toUtc().add(const Duration(hours: 9));
++//     return DateTime(kst.year, kst.month, kst.day);
++//   }
++// }
