commit 0ebe27be41bd790fb8ea6e44ff2cde33d11015ad
Merge: 347abaf 289e11a
Author: So2ln <sorrinj77@snu.ac.kr>
Date:   Mon Oct 6 19:54:38 2025 +0900

    WIP on dev: 347abaf ♻️ enum 구조화 및 AppText 위젯 추가 (#68)

diff --cc lib/core/routers/router.dart
index 5a834b7,5a834b7..dbe04ab
--- a/lib/core/routers/router.dart
+++ b/lib/core/routers/router.dart
@@@ -1,3 -1,3 +1,4 @@@
++import 'package:dailymoji/core/constants/app_text_strings.dart';
  import 'package:dailymoji/presentation/pages/my/character_setting/character_setting_page.dart';
  import 'package:dailymoji/presentation/pages/chat/chat_page.dart';
  import 'package:dailymoji/presentation/pages/home/home_page.dart';
@@@ -121,15 -121,15 +122,15 @@@ final routerProvider = Provider<GoRoute
            builder: (context, state) {
              final title = state.pathParameters["title"] ?? "";
              switch (title) {
--              case "언어 설정":
++              case AppTextStrings.languageSettings:
                  return PreparingPage(title);
--              case "공지사항":
--              case "이용 약관":
--              case "개인정보 처리방침":
--              case "상담센터 연결":
++              case AppTextStrings.notice:
++              case AppTextStrings.termsOfService:
++              case AppTextStrings.privacyPolicy:
++              case AppTextStrings.counselingCenter:
                  return InfoWebViewPage(title: title);
                default:
--                return PreparingPage("준비중");
++                return PreparingPage(AppTextStrings.pageIsPreparing);
              }
              // TODO: 위에 코드로 합쳐서 진행하였음 확인 후 필요없으면 삭제
              // if (title == "공지사항") {
diff --cc lib/data/data_sources/cluster_scores_data_source.dart
index 8b61bc6,8b61bc6..1dbcb3c
--- a/lib/data/data_sources/cluster_scores_data_source.dart
+++ b/lib/data/data_sources/cluster_scores_data_source.dart
@@@ -11,7 -11,7 +11,8 @@@ abstract interface class ClusterScoresD
      required DateTime endExclusive,
    });
  
--  Future<List<ClusterScoreDto>> fetchByUserAndMonth({
++  // RIN: 기존 fetchByUserAndMonth가 RPC 호출을 위한 새 함수로 변경되었습니다.
++  Future<List<ClusterScoreDto>> fetchDailyMaxByUserAndMonth({
      required String userId,
      required int year,
      required int month,
diff --cc lib/data/data_sources/cluster_scores_data_source_impl.dart
index d5fb10f,d5fb10f..74708a8
--- a/lib/data/data_sources/cluster_scores_data_source_impl.dart
+++ b/lib/data/data_sources/cluster_scores_data_source_impl.dart
@@@ -51,39 -51,39 +51,69 @@@ class ClusterScoresDataSourceImpl imple
      return (res as List).map((e) => ClusterScoreDto.fromJson(e)).toList();
    }
  
--  // ───────────────────────────────────────────────────────────────────────────
--  // 1) 특정 연도/월의 "해당 사용자" 데이터만
--  // ───────────────────────────────────────────────────────────────────────────
++// RIN: 기존에는 모든 데이터를 가져왔지만, 이제는 Supabase RPC를 호출합니다.
++  // Supabase 프로젝트에 'get_daily_max_cluster_scores' 함수를 이용한 코드!
    @override
--  Future<List<ClusterScoreDto>> fetchByUserAndMonth({
++  Future<List<ClusterScoreDto>> fetchDailyMaxByUserAndMonth({
      required String userId,
      required int year,
      required int month,
    }) async {
      try {
--      final startOfMonthLocal = DateTime(year, month, 1);
--      final startOfNextMonthLocal = (month == 12)
--          ? DateTime(year + 1, 1, 1)
--          : DateTime(year, month + 1, 1);
--
--      final startIso = startOfMonthLocal.toUtc().toIso8601String();
--      final endIso = startOfNextMonthLocal.toUtc().toIso8601String();
--
--      final res = await client
--          .from('cluster_scores')
--          .select() // 슬림 페이로드 권장
--          .eq('user_id', userId)
--          .gte('created_at', startIso)
--          .lt('created_at', endIso)
--          .order('created_at', ascending: true);
++      final response = await client.rpc(
++        'get_daily_max_cluster_scores',
++        params: {
++          'p_user_id': userId,
++          'p_year': year,
++          'p_month': month,
++        },
++      );
++
++      // RPC 결과는 List<dynamic> 타입이므로, DTO로 변환합니다.
++      final data = (response as List)
++          .map((json) => ClusterScoreDto.fromJson(json))
++          .toList();
  
--      return (res as List).map((e) => ClusterScoreDto.fromJson(e)).toList();
++      return data;
      } catch (e) {
--      throw Exception('fetchByUserAndMonth error: $e');
++      throw Exception("fetchDailyMaxByUserAndMonth RPC error: $e");
      }
    }
  }
  
++//   // ───────────────────────────────────────────────────────────────────────────
++//   // 1) 특정 연도/월의 "해당 사용자" 데이터만
++//   // ───────────────────────────────────────────────────────────────────────────
++//   @override
++//   Future<List<ClusterScoreDto>> fetchByUserAndMonth({
++//     required String userId,
++//     required int year,
++//     required int month,
++//   }) async {
++//     try {
++//       final startOfMonthLocal = DateTime(year, month, 1);
++//       final startOfNextMonthLocal = (month == 12)
++//           ? DateTime(year + 1, 1, 1)
++//           : DateTime(year, month + 1, 1);
++
++//       final startIso = startOfMonthLocal.toUtc().toIso8601String();
++//       final endIso = startOfNextMonthLocal.toUtc().toIso8601String();
++
++//       final res = await client
++//           .from('cluster_scores')
++//           .select() // 슬림 페이로드 권장
++//           .eq('user_id', userId)
++//           .gte('created_at', startIso)
++//           .lt('created_at', endIso)
++//           .order('created_at', ascending: true);
++
++//       return (res as List).map((e) => ClusterScoreDto.fromJson(e)).toList();
++//     } catch (e) {
++//       throw Exception('fetchByUserAndMonth error: $e');
++//     }
++//   }
++// }
++
  // import 'package:dailymoji/data/dtos/cluster_scores.dart';
  // import 'package:supabase_flutter/supabase_flutter.dart';
  
diff --cc lib/data/repositories/cluster_scores_repository_impl.dart
index c1e6e8b,c1e6e8b..7a25b4e
--- a/lib/data/repositories/cluster_scores_repository_impl.dart
+++ b/lib/data/repositories/cluster_scores_repository_impl.dart
@@@ -45,85 -45,85 +45,103 @@@ class ClusterScoresRepositoryImpl imple
      return _toEntities(dtos);
    }
  
--  // DTO → 슬림 Entity 매핑
--  List<ClusterScore> _toEntities(List<ClusterScoreDto> dtos) {
--    return dtos.map((d) {
--      return ClusterScore(
--        userId: d.userId ?? '',
--        createdAt:
--            d.createdAt ?? DateTime.fromMillisecondsSinceEpoch(0, isUtc: true),
--        cluster: d.cluster ?? '',
--        score: d.score ?? 0.0,
--      );
--    }).toList();
--  }
--
--  // 한달 데이터 불러오기
++// 🧡 [개선] 복잡했던 _pickDailyMax 함수가 제거되고, RPC를 호출하는 데이터 소스 함수를 직접 사용합니다.
++  // 이제 Repository는 데이터를 변환하는 역할에만 집중합니다.
    @override
    Future<List<ClusterScore>> fetchByUserAndMonth({
      required String userId,
      required int year,
      required int month,
    }) async {
--    final dtos = await dataSource.fetchByUserAndMonth(
++    final dtos = await dataSource.fetchDailyMaxByUserAndMonth(
        userId: userId,
        year: year,
        month: month,
      );
  
--    return _pickDailyMax(dtos);
++    // 서버에서 이미 계산된 데이터를 엔티티로 변환하기만 하면 됩니다.
++    return _toEntities(dtos);
    }
  
--  /// 요구사항:
--  /// 1) 한달 DTO 리스트 입력
--  /// 2) 하루별 최대 점수(동점이면 더 최신 createdAt) 한 건만 선택
--  /// 3) 최종 반환은 List<ClusterScore> (엔티티)
--  List<ClusterScore> _pickDailyMax(List<ClusterScoreDto> monthRows) {
--    if (monthRows.isEmpty) return <ClusterScore>[];
--
--    // 날짜(로컬 00:00)를 키로, 그 날짜의 최고 DTO 한 건을 값으로
--    final byDayMax = <DateTime, ClusterScoreDto>{};
--
--    for (final row in monthRows) {
--      final createdAt = row.createdAt;
--      final score = row.score;
--
--      // 필수 값 널이면 스킵 (기본값 채우는 것보다 왜곡이 적음)
--      if (createdAt == null || score == null) continue;
--
--      // "하루" 경계를 로컬(디바이스 TZ) 기준으로 묶음 (한국이면 KST)
--      final local = createdAt.toLocal();
--      final dayKey = DateTime(local.year, local.month, local.day); // 로컬 자정
--
--      final cur = byDayMax[dayKey];
--
--      // 점수 우선, 동점이면 더 최신 createdAt
--      if (cur == null ||
--          score > (cur.score ?? double.negativeInfinity) ||
--          (score == cur.score &&
--              cur.createdAt != null &&
--              createdAt.isAfter(cur.createdAt!))) {
--        byDayMax[dayKey] = row;
--      }
--    }
--
--    // 엔티티로 변환 + 정렬
--    // 정렬 기준을 '하루' 순서로 정확히 맞추고 싶다면 key(=dayKey)로 정렬
--    final sortedKeys = byDayMax.keys.toList()..sort();
--
--    final result = <ClusterScore>[];
--    for (final key in sortedKeys) {
--      final d = byDayMax[key]!; // key로 꺼낸 DTO (createdAt/score는 위에서 보장됨)
--
--      result.add(
--        ClusterScore(
--          userId: d.userId ?? '',
--          createdAt: d.createdAt!.toUtc(), // 저장/연산은 UTC 권장
--          cluster: d.cluster ?? 'unknown', // enum이면 parseCluster(d.cluster)
--          score: d.score!, // null 가드 했으니 !
--        ),
++  // DTO → 슬림 Entity 매핑
++  List<ClusterScore> _toEntities(List<ClusterScoreDto> dtos) {
++    return dtos.map((d) {
++      return ClusterScore(
++        userId: d.userId ?? '',
++        createdAt:
++            d.createdAt ?? DateTime.fromMillisecondsSinceEpoch(0, isUtc: true),
++        cluster: d.cluster ?? '',
++        score: d.score ?? 0.0,
        );
--    }
--    return result;
++    }).toList();
    }
++
++//   // 한달 데이터 불러오기
++//   @override
++//   Future<List<ClusterScore>> fetchByUserAndMonth({
++//     required String userId,
++//     required int year,
++//     required int month,
++//   }) async {
++//     final dtos = await dataSource.fetchByUserAndMonth(
++//       userId: userId,
++//       year: year,
++//       month: month,
++//     );
++
++//     return _pickDailyMax(dtos);
++//   }
++
++//   /// 요구사항:
++//   /// 1) 한달 DTO 리스트 입력
++//   /// 2) 하루별 최대 점수(동점이면 더 최신 createdAt) 한 건만 선택
++//   /// 3) 최종 반환은 List<ClusterScore> (엔티티)
++//   List<ClusterScore> _pickDailyMax(List<ClusterScoreDto> monthRows) {
++//     if (monthRows.isEmpty) return <ClusterScore>[];
++
++//     // 날짜(로컬 00:00)를 키로, 그 날짜의 최고 DTO 한 건을 값으로
++//     final byDayMax = <DateTime, ClusterScoreDto>{};
++
++//     for (final row in monthRows) {
++//       final createdAt = row.createdAt;
++//       final score = row.score;
++
++//       // 필수 값 널이면 스킵 (기본값 채우는 것보다 왜곡이 적음)
++//       if (createdAt == null || score == null) continue;
++
++//       // "하루" 경계를 로컬(디바이스 TZ) 기준으로 묶음 (한국이면 KST)
++//       final local = createdAt.toLocal();
++//       final dayKey = DateTime(local.year, local.month, local.day); // 로컬 자정
++
++//       final cur = byDayMax[dayKey];
++
++//       // 점수 우선, 동점이면 더 최신 createdAt
++//       if (cur == null ||
++//           score > (cur.score ?? double.negativeInfinity) ||
++//           (score == cur.score &&
++//               cur.createdAt != null &&
++//               createdAt.isAfter(cur.createdAt!))) {
++//         byDayMax[dayKey] = row;
++//       }
++//     }
++
++//     // 엔티티로 변환 + 정렬
++//     // 정렬 기준을 '하루' 순서로 정확히 맞추고 싶다면 key(=dayKey)로 정렬
++//     final sortedKeys = byDayMax.keys.toList()..sort();
++
++//     final result = <ClusterScore>[];
++//     for (final key in sortedKeys) {
++//       final d = byDayMax[key]!; // key로 꺼낸 DTO (createdAt/score는 위에서 보장됨)
++
++//       result.add(
++//         ClusterScore(
++//           userId: d.userId ?? '',
++//           createdAt: d.createdAt!.toUtc(), // 저장/연산은 UTC 권장
++//           cluster: d.cluster ?? 'unknown', // enum이면 parseCluster(d.cluster)
++//           score: d.score!, // null 가드 했으니 !
++//         ),
++//       );
++//     }
++//     return result;
++//   }
  }
diff --cc lib/data/repositories/session_repository.dart
index f75e07b,f75e07b..7864583
--- a/lib/data/repositories/session_repository.dart
+++ b/lib/data/repositories/session_repository.dart
@@@ -10,6 -10,6 +10,16 @@@ class DailyStat 
    final double? avg;
  
    const DailyStat({required this.day, this.max, this.min, this.avg});
++
++// RIN: RPC 응답(JSON)에서 DailyStat 객체로 변환하기 위한 factory 생성자 추가
++  factory DailyStat.fromJson(Map<String, dynamic> json) {
++    return DailyStat(
++      day: DateTime.parse(json['day']),
++      max: (json['max_g_score'] as num?)?.toDouble(),
++      min: (json['min_g_score'] as num?)?.toDouble(),
++      avg: (json['avg_g_score'] as num?)?.toDouble(),
++    );
++  }
  }
  
  class SessionRepository {
@@@ -17,116 -17,116 +27,156 @@@
  
    SessionRepository(this._client);
  
--  static const _table = 'sessions';
--  static const _cols = 'created_at, user_id, g_score';
--
--  /// 외부에서 한 번만 호출하면 1~3단계를 모두 수행해 반환합니다.
++// RIN: 클라이언트에서 직접 통계를 계산하는 로직을 제거하고,
++  // Supabase RPC를 호출하여 이미 계산된 통계 데이터를 가져옵니다.
++  // Supabase 프로젝트에 있는 'get_daily_gscore_stats' 함수를 이용한 코드
    Future<List<DailyStat>> fetchDailyStatsLast14Days({
      required String userId,
      DateTime? now,
--    bool fillMissingWithZero = false, // true면 데이터 없는 날을 0,0,0으로 채움
--  }) async {
--    final _now = now ?? DateTime.now();
--    final endAtUtc = _now.toUtc();
--    final startAtUtc = endAtUtc.subtract(const Duration(days: 14));
--
--    final sessions = await _fetchRawLast14Days(
--      userId: userId,
--      startAtUtc: startAtUtc,
--      endAtUtc: endAtUtc,
--    );
--
--    return _computeDailyStatsKst(
--      sessions14d: sessions,
--      startAtUtc: startAtUtc,
--      endAtUtc: endAtUtc,
--      fillMissingWithZero: fillMissingWithZero,
--    );
--  }
--
--  // ===== 1) 최근 14일 raw 세션 가져오기 =====
--  Future<List<SessionDto>> _fetchRawLast14Days({
--    required String userId,
--    required DateTime startAtUtc,
--    required DateTime endAtUtc,
++    bool fillMissingWithZero = false, // 이 옵션은 이제 서버 함수 로직에 따라 달라집니다.
    }) async {
      try {
--      final query = _client
--          .from(_table)
--          .select(_cols)
--          .eq('user_id', userId)
--          .gte('created_at', startAtUtc.toIso8601String())
--          .lt('created_at', endAtUtc.toIso8601String())
--          .order('created_at', ascending: true);
--
--      final List<dynamic> rows = await query;
--      return rows
++      final _now = now ?? DateTime.now();
++      // 서버 함수에 전달할 시작일과 종료일을 ISO 8601 형식의 문자열로 준비합니다.
++      final endDate = _now.toUtc();
++      final startDate = endDate.subtract(const Duration(days: 14));
++
++      final List<dynamic> response = await _client.rpc(
++        'get_daily_gscore_stats',
++        params: {
++          'p_user_id': userId,
++          'p_start_date': startDate.toIso8601String(),
++          'p_end_date': endDate.toIso8601String(),
++        },
++      );
++
++      // RPC 호출 결과를 DailyStat 객체 리스트로 변환합니다.
++      return response
            .cast<Map<String, dynamic>>()
--          .map(SessionDto.fromJson)
++          .map(DailyStat.fromJson)
            .toList();
      } on PostgrestException catch (e, s) {
--      log('_fetchRawLast14Days PostgrestException: ${e.message}',
++      log('fetchDailyStatsLast14Days PostgrestException: ${e.message}',
            stackTrace: s);
        rethrow;
      } catch (e, s) {
--      log('_fetchRawLast14Days Unknown error: $e', stackTrace: s);
++      log('fetchDailyStatsLast14Days Unknown error: $e', stackTrace: s);
        rethrow;
      }
    }
--
--  // ===== 2+3) 날짜(KST) 버킷팅 + max/min/avg 계산 =====
--  List<DailyStat> _computeDailyStatsKst({
--    required List<SessionDto> sessions14d,
--    required DateTime startAtUtc,
--    required DateTime endAtUtc,
--    required bool fillMissingWithZero,
--  }) {
--    // 2-1) 14일 키(자정 KST) 미리 생성
--    final startKst = _toKstMidnight(startAtUtc);
--    final endKst = _toKstMidnight(endAtUtc);
--    final map = <DateTime, List<double>>{};
--
--    for (DateTime d = startKst;
--        !d.isAfter(endKst.subtract(const Duration(days: 1)));
--        d = d.add(const Duration(days: 1))) {
--      map[d] = <double>[];
--    }
--
--    // 2-2) 세션을 해당 날짜 바구니에 담기
--    for (final s in sessions14d) {
--      if (s.createdAt == null || s.gScore == null) continue;
--      final kst = s.createdAt!.toUtc().add(const Duration(hours: 9));
--      final key = DateTime(kst.year, kst.month, kst.day);
--      if (map.containsKey(key)) {
--        map[key]!.add(s.gScore!);
--      }
--    }
--
--    // 3) 각 날짜별 max/min/avg 계산
--    final result = <DailyStat>[];
--    final keys = map.keys.toList()..sort((a, b) => a.compareTo(b));
--
--    for (final day in keys) {
--      final scores = map[day]!..sort();
--      if (scores!.isEmpty) {
--        result.add(
--          fillMissingWithZero
--              ? DailyStat(day: day, max: 0, min: 0, avg: 0)
--              : DailyStat(day: day, max: null, min: null, avg: null),
--        );
--        continue;
--      }
--      final max = scores.last;
--      final min = scores.first;
--      final avg = scores.reduce((a, b) => a + b) / scores.length;
--      result.add(DailyStat(day: day, max: max, min: min, avg: avg));
--    }
--    return result;
--  }
--
--  // UTC/로컬 어떤 값이 와도 KST 자정으로 내림
--  DateTime _toKstMidnight(DateTime dt) {
--    final kst = dt.toUtc().add(const Duration(hours: 9));
--    return DateTime(kst.year, kst.month, kst.day);
--  }
  }
++
++// RIN: 아래는 서버에서 계산된걸 가져오게 되면 여기서 처리하지 않아도 됩니다~!
++//   static const _table = 'sessions';
++//   static const _cols = 'created_at, user_id, g_score';
++
++//   /// 외부에서 한 번만 호출하면 1~3단계를 모두 수행해 반환합니다.
++//   Future<List<DailyStat>> fetchDailyStatsLast14Days({
++//     required String userId,
++//     DateTime? now,
++//     bool fillMissingWithZero = false, // true면 데이터 없는 날을 0,0,0으로 채움
++//   }) async {
++//     final _now = now ?? DateTime.now();
++//     final endAtUtc = _now.toUtc();
++//     final startAtUtc = endAtUtc.subtract(const Duration(days: 14));
++
++//     final sessions = await _fetchRawLast14Days(
++//       userId: userId,
++//       startAtUtc: startAtUtc,
++//       endAtUtc: endAtUtc,
++//     );
++
++//     return _computeDailyStatsKst(
++//       sessions14d: sessions,
++//       startAtUtc: startAtUtc,
++//       endAtUtc: endAtUtc,
++//       fillMissingWithZero: fillMissingWithZero,
++//     );
++//   }
++
++//   // ===== 1) 최근 14일 raw 세션 가져오기 =====
++//   Future<List<SessionDto>> _fetchRawLast14Days({
++//     required String userId,
++//     required DateTime startAtUtc,
++//     required DateTime endAtUtc,
++//   }) async {
++//     try {
++//       final query = _client
++//           .from(_table)
++//           .select(_cols)
++//           .eq('user_id', userId)
++//           .gte('created_at', startAtUtc.toIso8601String())
++//           .lt('created_at', endAtUtc.toIso8601String())
++//           .order('created_at', ascending: true);
++
++//       final List<dynamic> rows = await query;
++//       return rows
++//           .cast<Map<String, dynamic>>()
++//           .map(SessionDto.fromJson)
++//           .toList();
++//     } on PostgrestException catch (e, s) {
++//       log('_fetchRawLast14Days PostgrestException: ${e.message}',
++//           stackTrace: s);
++//       rethrow;
++//     } catch (e, s) {
++//       log('_fetchRawLast14Days Unknown error: $e', stackTrace: s);
++//       rethrow;
++//     }
++//   }
++
++//   // ===== 2+3) 날짜(KST) 버킷팅 + max/min/avg 계산 =====
++//   List<DailyStat> _computeDailyStatsKst({
++//     required List<SessionDto> sessions14d,
++//     required DateTime startAtUtc,
++//     required DateTime endAtUtc,
++//     required bool fillMissingWithZero,
++//   }) {
++//     // 2-1) 14일 키(자정 KST) 미리 생성
++//     final startKst = _toKstMidnight(startAtUtc);
++//     final endKst = _toKstMidnight(endAtUtc);
++//     final map = <DateTime, List<double>>{};
++
++//     for (DateTime d = startKst;
++//         !d.isAfter(endKst.subtract(const Duration(days: 1)));
++//         d = d.add(const Duration(days: 1))) {
++//       map[d] = <double>[];
++//     }
++
++//     // 2-2) 세션을 해당 날짜 바구니에 담기
++//     for (final s in sessions14d) {
++//       if (s.createdAt == null || s.gScore == null) continue;
++//       final kst = s.createdAt!.toUtc().add(const Duration(hours: 9));
++//       final key = DateTime(kst.year, kst.month, kst.day);
++//       if (map.containsKey(key)) {
++//         map[key]!.add(s.gScore!);
++//       }
++//     }
++
++//     // 3) 각 날짜별 max/min/avg 계산
++//     final result = <DailyStat>[];
++//     final keys = map.keys.toList()..sort((a, b) => a.compareTo(b));
++
++//     for (final day in keys) {
++//       final scores = map[day]!..sort();
++//       if (scores!.isEmpty) {
++//         result.add(
++//           fillMissingWithZero
++//               ? DailyStat(day: day, max: 0, min: 0, avg: 0)
++//               : DailyStat(day: day, max: null, min: null, avg: null),
++//         );
++//         continue;
++//       }
++//       final max = scores.last;
++//       final min = scores.first;
++//       final avg = scores.reduce((a, b) => a + b) / scores.length;
++//       result.add(DailyStat(day: day, max: max, min: min, avg: avg));
++//     }
++//     return result;
++//   }
++
++//   // UTC/로컬 어떤 값이 와도 KST 자정으로 내림
++//   DateTime _toKstMidnight(DateTime dt) {
++//     final kst = dt.toUtc().add(const Duration(hours: 9));
++//     return DateTime(kst.year, kst.month, kst.day);
++//   }
++// }
